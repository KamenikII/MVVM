# MVVM Example
#### (Model - View - ViewModel)

Суть в том, что мы разбиваем код на 3 части. MVVM предлагает отделить логику *View(UI)* от основной части бизнес-логики: 
* **Model** -  работает вместе с *ViewModel*, чтобы сполучать и сохранять данные. Отвечает за абстракцию источников данных;
* **View** - информирует *ViewModel* о действиях пользователя. Наблюдает за *ViewModel* и не содержит никакой логики приложения;
* **ViewModel** - представляет потоки данных, которые связаны с *View*. Служит связующим звеном между *Model* и *View*.

### Связь:
![](/MVVM.PNG)
![](/MVVM2.PNG)
![](/MVVM3.PNG)

### Ключевые моменты MVVM:
1) Похож чем-то на MVP, только вместо *presenter*, в MVVM *ViewModel*;
2) *ViewModel* не содержит ссылок на *View*;
4) Нет методов запуска для обновления *View*.

### Способы реализации: 
1) Использование библиотеки DataBinding, выпущенной Google;
2) Использование других инструментов, таких как RxJava, для привязки данных.

### Плюсы:
* Повышенная возможность повторного использования кода;
* Все модули независимы, что улучшает тестируемость каждого уровня;
* Может быть сколько угодно *View*;
* Структурирует файлы проекта удобным в обслуживании способом и позволяет легко вносить изменения.

### Минусы:
* Не подходит для небольших проектов;
* Если логика привязки данных сложна, отладка будет сложнее;
* Много кода
* Может быть менее производительным;

### Что по коду:
* Использовалось root для помощи с бд (SQLite)
* Model в нашем случае это repository, db и adapters, dao
* View - это MainActivity
* ViewModel - viewmodel
* принцип единой ответственности соблюдён
* есть дата классы
